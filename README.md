
# Orbit-NLU (LoRA) Исследование выполнено за счет гранта Российского научного фонда № 24-29-00706

Orbit-NLU — это проект для дообучения языковой модели (LLM) с использованием LoRA для преобразования русскоязычных запросов о спутниках в JSON-фильтры. Проект оптимизирован для работы с астрономическими и баллистическими данными малых и больших космических аппаратов (КА). Модель принимает текстовые запросы на русском языке и возвращает структурированные JSON-фильтры с параметрами, такими как `coverage`, `altitude`, `orbitType`, и др., которые можно использовать для фильтрации TLE (Two-Line Element) данных и проверки физической осуществимости через Pro42.

## Основные возможности
- **Дообучение модели**: Использует базовую модель (см. `model_name` в `config.yaml`) с LoRA для маппинга русских промтов на JSON.
- **Локальный инференс**: Генерация JSON-фильтров из текста через `infer.py`.
- **FastAPI-сервер**: REST API для обработки запросов через `server.py`.
- **Интеграция со Spring**: JSON-фильтры можно передавать в Spring-приложение для фильтрации TLE и проверки в Pro42.
- **Docker**: Поддержка контейнеризации для развёртывания на GPU.

## Требования
- Python 3.10+
- NVIDIA GPU с CUDA 12.1+ (рекомендуется для обучения и инференса)
- Зависимости: см. `requirements.txt` в корне проекта для списка библиотек и их версий.

### Описание файлов
- **`config.yaml`**: Конфигурация для всех скриптов: модель, пути к данным, параметры LoRA, `system_prompt` и `prompt_template`.
- **`train.py`**: Скрипт для дообучения модели с LoRA. Сохраняет адаптер в `outputs/orbit-nlu-lora`.
- **`infer.py`**: Скрипт для локального инференса: преобразует текст в JSON-фильтры.
- **`server.py`**: FastAPI-сервер с API `/parse` для обработки промтов.
- **`requirements.txt`**: Список зависимостей с версиями.
- **`Dockerfile`**: Файл для сборки Docker-образа сервера.
- **`prompts.jsonl`**: Данные для обучения, сгенерированные Scala-скриптом `GeneratePrompt.scala`.
- **`data/`**: Опциональная директория для тренировочных (`train.jsonl`) и валидационных (`val.jsonl`) данных.
- **`outputs/orbit-nlu-lora/`**: Директория с LoRA-адаптером и токенизатором после обучения.

## Быстрый старт

1. **Установка зависимостей**:
   ```bash
   pip install -r requirements.txt
   ```

2. **Генерация обучающих данных**:
   - Используйте python-скрипт `generatePrompt.py` для создания `prompts.jsonl`:
     ```bash
     python generatePrompt.py --count 10000
     ```

3. **Дообучение модели**:
   - Настройте `config.yaml` (проверьте `model_name`, `dataset_path`, `output_dir`).
   - Запустите обучение:
     ```bash
     python train.py
     ```

4. **Локальный инференс**:
   - Проверьте модель:
     ```bash
     python infer.py
     ```
   - Пример входного промта: "Подбери низкую группировку, видит Россию, масса до 10 кг".
   - Пример вывода см. в разделе "Примеры".

5. **Запуск FastAPI-сервера**:
   - Запустите сервер:
     ```bash
     uvicorn server:app --host 0.0.0.0 --port 8000
     ```
   - Отправьте POST-запрос:
     ```bash
     curl -X POST http://localhost:8000/parse -H "Content-Type: application/json" -d '{"text":"Подбери низкую группировку, видит Россию, масса до 10 кг"}'
     ```

## Docker
1. **Сборка образа**:
   ```bash
   docker build -t orbit-nlu:latest .
   ```

2. **Запуск контейнера**:
   ```bash
   docker run --gpus all -p 8000:8000 orbit-nlu:latest
   ```
   - Требуется NVIDIA Container Toolkit для поддержки GPU.

## Интеграция со Spring
1. **API**: Эндпоинт `/parse` принимает POST-запросы с JSON `{ "text": "..." }` и возвращает JSON-фильтры.
2. **Использование**:
   - В Spring отправляйте запросы к `http://<host>:8000/parse`.
   - Используйте поле `filters` из ответа для фильтрации TLE-данных.
   - Передайте отфильтрованные TLE в Pro42 для проверки (например, орбитальной устойчивости).
3. **Пример запроса в Spring**:
   ```java
   RestTemplate restTemplate = new RestTemplate();
   String url = "http://localhost:8000/parse";
   String requestJson = "{\"text\": \"Подбери низкую группировку, видит Россию, масса до 10 кг\"}";
   ResponseEntity<String> response = restTemplate.postForEntity(url, requestJson, String.class);
   System.out.println(response.getBody());
   ```

## Примеры
**Входной промт**:
```
Подбери спутник на геостационарной орбите над Китаем с массой 100 кг
```

**Выходной JSON** (зависит от обученной модели, см. `prompts.jsonl`):
```json
{
  "coverage": "Китай",
  "altitude": "~36000 км",
  "orbitType": "GEO",
  "status": "активен",
  "formFactor": "6U",
  "mass": "100 кг",
  "scale": "малые",
  "tleDate": "2025-01-01",
  "numberOfSatellites": "1"
}
```

## Рекомендации
- **Датасет**: Для лучшей точности сгенерируйте ≥10,000 промтов:
  ```bash
  scala GeneratePrompt.scala 10000
  ```
- **Точность**: Если JSON-фильтры некорректны, увеличьте `num_train_epochs` в `config.yaml` или настройте LoRA (`r=32`).
- **Продакшен**:
  - Добавьте аутентификацию в `server.py` для безопасности.
  - Используйте `torch.compile` для ускорения инференса (PyTorch>=2.0).
- **Логирование**: Логи (`INFO`-уровень) выводятся в консоль. Проверьте их для отладки.
- **Структура проекта**: Для обновления структуры в этом README выполните:
  ```bash
  tree -I '__pycache__|.git|*.pyc' > structure.txt
  ```
  Затем вставьте содержимое `structure.txt` в раздел "Структура проекта".

